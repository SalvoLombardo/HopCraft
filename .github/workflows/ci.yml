name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  # ---------------------------------------------------------------------------
  # Lint — ruff (pyflakes + pycodestyle, ignora lunghezza riga)
  # ---------------------------------------------------------------------------
  lint:
    name: Lint (ruff)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install ruff
        run: pip install "ruff>=0.9.0"

      - name: Run ruff
        run: ruff check --select E,F --line-length 100 backend/app backend/tests

  # ---------------------------------------------------------------------------
  # Test — pytest (tutte le dipendenze esterne sono mockate, nessun servizio reale)
  # ---------------------------------------------------------------------------
  test:
    name: Test (pytest)
    runs-on: ubuntu-latest
    needs: lint

    env:
      # Valori dummy — i test mockano DB e Redis, le chiavi API non vengono usate
      DATABASE_URL: postgresql+asyncpg://test:test@localhost:5432/hopcraft
      DB_PASSWORD: test
      REDIS_URL: redis://localhost:6379/0
      FLIGHT_PROVIDER: amadeus
      LLM_PROVIDER: gemini

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: pip
          cache-dependency-path: backend/requirements.txt

      - name: Install dependencies
        run: pip install -r backend/requirements.txt

      - name: Run pytest
        working-directory: backend
        run: pytest tests/ -v

  # ---------------------------------------------------------------------------
  # Deploy — solo su push a main (non su PR)
  # Prerequisiti GitHub Secrets:
  #   AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY  → S3 + CloudFront
  #   S3_BUCKET_NAME                            → output di `terraform output s3_bucket_name`
  #   CLOUDFRONT_DISTRIBUTION_ID               → output di `terraform output cloudfront_distribution_id`
  #   EC2_HOST                                  → output di `terraform output ec2_public_ip`
  #   EC2_SSH_KEY                               → contenuto di ~/.ssh/hopcraft (chiave PRIVATA)
  #
  # Setup una-tantum prima del primo deploy:
  #   1. `terraform apply` nella cartella infra/
  #   2. Caricare i file su EC2:
  #        scp -i ~/.ssh/hopcraft docker-compose.prod.yml nginx.prod.conf ec2-user@EC2_IP:/opt/hopcraft/
  #        scp -i ~/.ssh/hopcraft .env.prod ec2-user@EC2_IP:/opt/hopcraft/
  #   3. Impostare il package GHCR su Public:
  #        GitHub → Settings → Packages → hopcraft-backend → Change visibility → Public
  #   4. Aggiungere i secrets sopra nelle impostazioni del repository GitHub
  # ---------------------------------------------------------------------------
  deploy:
    name: Deploy (AWS EC2 + S3)
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    permissions:
      contents: read
      packages: write   # necessario per push su GHCR

    steps:
      - uses: actions/checkout@v4

      # -----------------------------------------------------------------------
      # Backend: build immagine Docker e push su GHCR
      # -----------------------------------------------------------------------
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: backend
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/hopcraft-backend:latest
            ghcr.io/${{ github.repository_owner }}/hopcraft-backend:${{ github.sha }}

      # -----------------------------------------------------------------------
      # Frontend: build React e upload su S3
      # -----------------------------------------------------------------------
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: npm
          cache-dependency-path: frontend/package-lock.json

      - name: Install frontend dependencies
        working-directory: frontend
        run: npm ci

      - name: Build frontend
        working-directory: frontend
        run: npm run build
        # api.js usa percorsi relativi (/api/v1/...) — nessuna env var necessaria

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-south-1

      - name: Upload frontend to S3
        run: aws s3 sync frontend/dist s3://${{ secrets.S3_BUCKET_NAME }} --delete

      - name: Invalidate CloudFront cache
        run: |
          aws cloudfront create-invalidation \
            --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} \
            --paths "/*"

      # -----------------------------------------------------------------------
      # Backend: SSH su EC2 → pull immagine → riavvio container
      # -----------------------------------------------------------------------
      - name: Deploy backend to EC2
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            cd /opt/hopcraft

            # Imposta il tag dell'immagine per questo deploy
            export BACKEND_IMAGE="ghcr.io/${{ github.repository_owner }}/hopcraft-backend:${{ github.sha }}"

            # Pull immagine aggiornata (GHCR pubblico — no autenticazione)
            docker pull "$BACKEND_IMAGE"

            # Riavvia solo backend + nginx (postgres e redis rimangono invariati)
            docker compose -f docker-compose.prod.yml up -d --no-deps backend nginx

            # Rimuovi immagini vecchie per liberare spazio (t3.micro ha 20GB)
            docker image prune -f
